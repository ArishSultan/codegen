/*
Copyright 2022 The Apex Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import {
  Alias,
  AnyType,
  BaseVisitor,
  Context,
  Enum,
  Kind,
  Named,
  Optional,
  Primitive,
  PrimitiveName,
  Type,
  Union,
  Map,
  List,
  Field,
} from "@apexlang/core/model";
import {
  capitalize,
  isNamed,
  isObject,
  isPrimitive,
  isService,
  isVoid,
} from "../utils";
import { fieldName, methodName } from "./helpers";

export type NamedType = Alias | Type | Union | Enum;

export class GRPCVisitor extends BaseVisitor {
  private input: { [name: string]: NamedType } = {};
  private output: { [name: string]: NamedType } = {};

  visitNamespaceBefore(context: Context): void {
    const ns = context.namespace;
    const visitor = new InputOutputVisitor(this.writer);
    ns.accept(context, visitor);
    this.input = visitor.input;
    this.output = visitor.output;

    const packageName = context.config.package || "module";
    const module = context.config.module;
    const protoPackage = context.config.protoPackage || module + "/proto";
    this.write(`// Code generated by @apexlang/codegen. DO NOT EDIT.

package ${packageName}
  
import (
  "context"

  "google.golang.org/grpc"\n`);
    visitor.imports.forEach((i) => this.write(`"${i}"\n`));

    this.write(`
	"github.com/apexlang/api-go/transport/tgrpc"
  "github.com/apexlang/api-go/convert"
	pb "${protoPackage}"
)

const _ = convert.Package\n\n`);
    super.triggerNamespaceBefore(context);
  }

  visitRoleBefore(context: Context): void {
    if (!isService(context)) {
      return;
    }

    const { role } = context;
    this.write(`func ${role.name}GRPC(s ${role.name}) tgrpc.RegisterFn {
  return func(server grpc.ServiceRegistrar) {
    pb.Register${role.name}Server(server, New${role.name}GRPCWrapper(s))
  }
}

type ${role.name}GRPCWrapper struct {
  pb.Unimplemented${role.name}Server
  service ${role.name}
}

func New${role.name}GRPCWrapper(service ${role.name}) *${role.name}GRPCWrapper {
  return &${role.name}GRPCWrapper{
    service: service,
  }
}\n\n`);
  }

  visitOperation(context: Context): void {
    if (!isService(context)) {
      return;
    }

    const { role, operation } = context;
    const returnType = operation.type;
    const operName = capitalize(operation.name);
    this.write(
      `func (s *${role.name}GRPCWrapper) ${operName}(ctx context.Context, `
    );
    if (operation.isUnary()) {
      const param = operation.parameters[0];
      switch (param.type.kind) {
        case Kind.Void:
          this.write(`*emptypb.Empty`);
          break;
        case Kind.Primitive:
          const p = param.type as Primitive;
          this.write(`${param.name} ${primitiveWrapperType(p.name)}`);
          break;
        case Kind.Enum:
          const e = param.type as Enum;
          this.write(`${param.name} *pb.${e.name}Value`);
          break;
        case Kind.Type:
          this.write(`request *pb.${(param.type as Named).name}`);
          break;
      }
    } else if (operation.parameters.length > 0) {
      this.write(`args *pb.${operName}Args`);
    } else {
      this.write(`_ *emptypb.Empty`);
    }
    this.write(`) (`);
    switch (returnType.kind) {
      case Kind.Void:
        this.write(`*emptypb.Empty`);
        break;
      case Kind.Primitive:
        const p = operation.type as Primitive;
        this.write(primitiveWrapperType(p.name));
        break;
      case Kind.Enum:
        this.write(`*pb.${(returnType as Enum).name}Value`);
        break;
      case Kind.Type:
        this.write(`*pb.${(returnType as Named).name}`);
        break;
    }
    this.write(`, error) {\n`);

    if (operation.isUnary()) {
      const param = operation.parameters[0];
      switch (param.type.kind) {
        case Kind.Primitive:
          const p = param.type as Primitive;
          switch (p.name) {
            case PrimitiveName.I8:
              this.write(`input := int8(${param.name}.Value)\n`);
              break;
            case PrimitiveName.I16:
              this.write(`input := int16(${param.name}.Value)\n`);
              break;
            case PrimitiveName.U8:
              this.write(`input := uint8(${param.name}.Value)\n`);
              break;
            case PrimitiveName.U16:
              this.write(`input := uint16(${param.name}.Value)\n`);
              break;
            default:
              this.write(`input := ${param.name}.Value\n`);
              break;
          }
          break;
        case Kind.Enum:
          const e = param.type as Enum;
          this.write(`input := ${e.name}(${param.name}.Value)\n`);
          break;
        default:
          this.write(
            `input := convertInput${
              (operation.parameters[0].type as Named).name
            }(request)\n`
          );
          break;
      }
      if (!isVoid(operation.type)) {
        this.write(`result, `);
      }
      this.write(`err := s.service.${methodName(
        operation,
        operation.name
      )}(ctx, ${isObject(param.type) ? "" : ""}input)
      if err != nil {
      	return nil, tgrpc.Error(err)
      }\n`);
    } else {
      const params = operation.parameters
        .map((p) => `, args.${capitalize(p.name)}`)
        .join("");
      if (!isVoid(operation.type)) {
        this.write(`result, `);
      }
      this.write(`err := s.service.${methodName(
        operation,
        operation.name
      )}(ctx${params})
      if err != nil {
      	return nil, tgrpc.Error(err)
      }\n`);
    }

    switch (operation.type.kind) {
      case Kind.Void:
        this.write(`return &emptypb.Empty{}, nil\n`);
        break;
      case Kind.Type:
        this.write(
          `return convertOutput${(operation.type as Named).name}(result), nil\n`
        );
        break;
      case Kind.Enum:
        const e = operation.type as Enum;
        this.write(
          `return &pb.${e.name}Value{Value: pb.${e.name}(result)}, nil\n`
        );
        break;
      case Kind.Primitive:
        const p = operation.type as Primitive;
        switch (p.name) {
          case PrimitiveName.String:
            this.write(`return &wrapperspb.StringValue{Value: result}, nil\n`);
            break;
          case PrimitiveName.I64:
            this.write(`return &wrapperspb.Int64Value{Value: result}, nil\n`);
            break;
          case PrimitiveName.I32:
            this.write(`return &wrapperspb.Int32Value{Value: result}, nil\n`);
            break;
          case PrimitiveName.I16:
          case PrimitiveName.I8:
            this.write(
              `return &wrapperspb.Int32Value{Value: int32(result)}, nil\n`
            );
            break;
          case PrimitiveName.U64:
            this.write(`return &wrapperspb.UInt64Value{Value: result}, nil\n`);
            break;
          case PrimitiveName.U32:
            this.write(`return &wrapperspb.UInt32Value{Value: result}, nil\n`);
            break;
          case PrimitiveName.U16:
          case PrimitiveName.U8:
            this.write(
              `return &wrapperspb.UInt32Value{Value: uint32(result)}, nil\n`
            );
            break;
          case PrimitiveName.F64:
            this.write(`return &wrapperspb.DoubleValue{Value: result}, nil\n`);
            break;
          case PrimitiveName.F32:
            this.write(`return &wrapperspb.FloatValue{Value: result}, nil\n`);
            break;
          case PrimitiveName.Bool:
            this.write(`return &wrapperspb.BoolValue{Value: result}, nil\n`);
            break;
          case PrimitiveName.Bytes:
            this.write(`return &wrapperspb.BytesValue{Value: result}, nil\n`);
            break;
        }
    }
    this.write(`}\n\n`);
  }

  visitNamespaceAfter(context: Context): void {
    for (let name of Object.keys(this.input)) {
      const named = this.input[name];
      switch (named.kind) {
        case Kind.Type:
          const t = named as Type;
          this.writeInputType(t);
          break;
      }
    }

    for (let name of Object.keys(this.output)) {
      const named = this.output[name];
      switch (named.kind) {
        case Kind.Type:
          const t = named as Type;
          this.writeOutputType(t);
          break;
      }
    }
  }

  writeOutputType(t: Type) {
    this.write(`func convertOutput${t.name}(from *${t.name}) *pb.${t.name} {
      if from == nil {
        return nil
      }
      return &pb.${t.name}{\n`);
    t.fields.forEach((f) => {
      switch (f.type.kind) {
        case Kind.Optional:
          const optType = (f.type as Optional).type;
          switch (optType.kind) {
            case Kind.Primitive:
              const prim = optType as Primitive;
              let wrapperStart = "";
              let wrapperEnd = "";
              switch (prim.name) {
                case PrimitiveName.I16:
                  wrapperStart = `tgrpc.ConvertOutputI16Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.I8:
                  wrapperStart = `tgrpc.ConvertOutputI8Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.U16:
                  wrapperStart = `tgrpc.ConvertOutputU16Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.U8:
                  wrapperStart = `tgrpc.ConvertOutputU8Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.DateTime:
                  wrapperStart = `tgrpc.ConvertOutputTimestamp(`;
                  wrapperEnd = `)`;
                  break;
              }
              this.write(
                `${capitalize(f.name)}: ${wrapperStart}from.${fieldName(
                  f,
                  f.name
                )}${wrapperEnd},\n`
              );
              break;
            case Kind.Type:
              const ft = optType as Type;
              this.write(
                `${capitalize(f.name)}: convertOutput${
                  ft.name
                }(from.${fieldName(f, f.name)}),\n`
              );
              break;
          }
          break;
        case Kind.Primitive:
          const prim = f.type as Primitive;
          let wrapperStart = "";
          let wrapperEnd = "";
          switch (prim.name) {
            case PrimitiveName.I16:
            case PrimitiveName.I8:
              wrapperStart = `int32(`;
              wrapperEnd = ")";
              break;
            case PrimitiveName.U16:
            case PrimitiveName.U8:
              wrapperStart = `uint32(`;
              wrapperEnd = ")";
              break;
            case PrimitiveName.DateTime:
              wrapperStart = `timestamppb.New(`;
              wrapperEnd = `)`;
              break;
          }
          this.write(
            `${capitalize(f.name)}: ${wrapperStart}from.${fieldName(
              f,
              f.name
            )}${wrapperEnd},\n`
          );
          break;
        case Kind.Type:
          const ft = f.type as Type;
          const ref = ft.name == t.name ? "" : "&";
          this.write(
            `${capitalize(f.name)}: convertOutput${
              ft.name
            }(${ref}from.${fieldName(f, f.name)}),\n`
          );
          break;
        case Kind.Map:
          const m = f.type as Map;
          if (isObject(m.valueType)) {
            const n = (
              m.valueType.kind == Kind.Optional
                ? (m.valueType as Optional).type
                : m.valueType
            ) as Named;
            const ptr = m.valueType.kind == Kind.Optional ? "" : "Ptr";
            this.write(
              `${capitalize(f.name)}: convert.Map${ptr}(from.${fieldName(
                f,
                f.name
              )}, convertOutput${n.name}),\n`
            );
          } else {
            this.write(
              `${capitalize(f.name)}: from.${fieldName(f, f.name)},\n`
            );
          }
          break;
        case Kind.List:
          const l = f.type as List;
          if (isObject(l.type)) {
            const n = (
              l.type.kind == Kind.Optional ? (l.type as Optional).type : l.type
            ) as Named;
            const ptr = l.type.kind == Kind.Optional ? "" : "Ptr";
            this.write(
              `${capitalize(f.name)}: convert.Slice${ptr}(from.${fieldName(
                f,
                f.name
              )}, convertOutput${n.name}),\n`
            );
          } else {
            this.write(
              `${capitalize(f.name)}: from.${fieldName(f, f.name)},\n`
            );
          }
          break;
      }
    });
    this.write(`\t}
  }\n\n`);
  }

  writeInputType(t: Type) {
    this.write(`func convertInput${t.name}(from *pb.${t.name}) *${t.name} {
      if from == nil {
        return nil
      }
      return &${t.name}{\n`);
    t.fields.forEach((f) => this.writeInputField(t, f));
    this.write(`\t}
  }\n\n`);
  }

  writeInputField(t: Type, f: Field) {
    switch (f.type.kind) {
      case Kind.Optional:
        const optType = (f.type as Optional).type;
        switch (optType.kind) {
          case Kind.Primitive:
            const prim = optType as Primitive;
            let wrapperStart = "";
            let wrapperEnd = "";
            switch (prim.name) {
              case PrimitiveName.I16:
                wrapperStart = `tgrpc.ConvertInputI16Ptr(`;
                wrapperEnd = ")";
                break;
              case PrimitiveName.I8:
                wrapperStart = `tgrpc.ConvertInputI8Ptr(`;
                wrapperEnd = ")";
                break;
              case PrimitiveName.U16:
                wrapperStart = `tgrpc.ConvertInputU16Ptr(`;
                wrapperEnd = ")";
                break;
              case PrimitiveName.U8:
                wrapperStart = `tgrpc.ConvertInputU8Ptr(`;
                wrapperEnd = ")";
                break;
              case PrimitiveName.DateTime:
                wrapperStart = `tgrpc.ConvertInputTimestamp(`;
                wrapperEnd = `)`;
                break;
            }
            this.write(
              `${fieldName(f, f.name)}: ${wrapperStart}from.${capitalize(
                f.name
              )}${wrapperEnd},\n`
            );
            break;
          case Kind.Type:
            const ft = optType as Type;
            this.write(
              `${fieldName(f, f.name)}: convertInput${
                ft.name
              }(from.${capitalize(f.name)}),\n`
            );
            break;
        }
        break;
      case Kind.Primitive:
        const prim = f.type as Primitive;
        let wrapperStart = "";
        let wrapperEnd = "";
        switch (prim.name) {
          case PrimitiveName.I16:
            wrapperStart = `int16(`;
            wrapperEnd = ")";
            break;
          case PrimitiveName.I8:
            wrapperStart = `int8(`;
            wrapperEnd = ")";
            break;
          case PrimitiveName.U16:
            wrapperStart = `uint16(`;
            wrapperEnd = ")";
            break;
          case PrimitiveName.U8:
            wrapperStart = `uint8(`;
            wrapperEnd = ")";
            break;
          case PrimitiveName.DateTime:
            wrapperEnd = `.AsTime()`;
            break;
        }
        this.write(
          `${fieldName(f, f.name)}: ${wrapperStart}from.${capitalize(
            f.name
          )}${wrapperEnd},\n`
        );
        break;
      case Kind.Type:
        const ft = f.type as Type;
        this.write(
          `${capitalize(f.name)}: *convertInput${ft.name}(from.${fieldName(
            f,
            f.name
          )}),\n`
        );
        break;
      case Kind.Map:
        const m = f.type as Map;
        if (isObject(m.valueType)) {
          const n = m.valueType as Named;
          this.write(
            `${fieldName(f, f.name)}: convert.MapRef(from.${capitalize(
              f.name
            )}, convertInput${n.name}),\n`
          );
        } else {
          this.write(`${fieldName(f, f.name)}: from.${capitalize(f.name)},\n`);
        }
        break;
      case Kind.List:
        const l = f.type as List;
        if (isObject(l.type)) {
          const n = l.type as Named;
          this.write(
            `${fieldName(f, f.name)}: convert.SliceRef(from.${capitalize(
              f.name
            )}, convertInput${n.name}),\n`
          );
        } else {
          this.write(`${fieldName(f, f.name)}: from.${capitalize(f.name)},\n`);
        }
        break;
    }
  }
}

export class InputOutputVisitor extends BaseVisitor {
  imports: Set<string> = new Set();
  input: { [name: string]: NamedType } = {};
  output: { [name: string]: NamedType } = {};
  // hasDateTime: boolean = false;
  // hasEmpty: boolean = false;

  visitOperation(context: Context): void {
    if (!isService(context)) {
      return;
    }
    const { operation } = context;
    if (isVoid(operation.type) || operation.parameters.length == 0) {
      this.imports.add("google.golang.org/protobuf/types/known/emptypb");
    }
    if (operation.isUnary()) {
      this.checkSingleType(operation.parameters[0].type);
    }
    this.checkSingleType(operation.type);
    this.checkType(operation.type, this.output);
  }

  visitParameter(context: Context): void {
    if (!isService(context)) {
      return;
    }
    const { parameter } = context;
    this.checkType(parameter.type, this.input);
  }

  checkSingleType(a: AnyType) {
    if (isPrimitive(a)) {
      const p = a as Primitive;
      if (p.name == PrimitiveName.DateTime) {
        this.imports.add("google.golang.org/protobuf/types/known/timestamppb");
      } else {
        this.imports.add("google.golang.org/protobuf/types/known/wrapperspb");
      }
    }
  }

  checkType(
    a: AnyType,
    m: { [name: string]: AnyType },
    types: Set<string> = new Set()
  ) {
    // Prevent stack overflow
    if (isNamed(a)) {
      const n = a as Named;
      if (types.has(n.name)) {
        return;
      }
      types.add(n.name);
    }

    switch (a.kind) {
      case Kind.Primitive:
        const p = a as Primitive;
        if (p.name == PrimitiveName.DateTime) {
          this.imports.add(
            "google.golang.org/protobuf/types/known/timestamppb"
          );
        }
        break;

      case Kind.Type:
        const t = a as Type;
        m[t.name] = t;
        t.fields.forEach((f) => this.checkType(f.type, m, types));
        break;

      case Kind.Union:
        const u = a as Union;
        // m[t.name] = u; // TODO
        u.types.forEach((t) => this.checkType(t, m, types));
        break;

      case Kind.Alias:
        const al = a as Alias;
        // m[t.name] = al; // TODO
        this.checkType(al.type, m, types);
        break;

      case Kind.Map:
        const ma = a as Map;
        this.checkType(ma.keyType, m, types);
        this.checkType(ma.valueType, m, types);
        break;

      case Kind.List:
        const l = a as List;
        this.checkType(l.type, m, types);
        break;

      case Kind.Optional:
        const o = a as Optional;
        this.checkType(o.type, m, types);
        break;
    }
  }
}

function primitiveWrapperType(name: PrimitiveName): string {
  switch (name) {
    case PrimitiveName.String:
      return `*wrapperspb.StringValue`;
    case PrimitiveName.I64:
      return `*wrapperspb.Int64Value`;
    case PrimitiveName.I32:
    case PrimitiveName.I16:
    case PrimitiveName.I8:
      return `*wrapperspb.Int32Value`;
    case PrimitiveName.U64:
      return `*wrapperspb.UInt64Value`;
    case PrimitiveName.U32:
    case PrimitiveName.U16:
    case PrimitiveName.U8:
      return `*wrapperspb.UInt32Value`;
    case PrimitiveName.F64:
      return `*wrapperspb.DoubleValue`;
    case PrimitiveName.F32:
      return `*wrapperspb.FloatValue`;
    case PrimitiveName.Bool:
      return `*wrapperspb.BoolValue`;
    case PrimitiveName.Bytes:
      return `*wrapperspb.BytesValue`;
  }

  return "unknown";
}
