/*
Copyright 2022 The Apex Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import {
  Alias,
  AnyType,
  BaseVisitor,
  Context,
  Enum,
  Kind,
  Named,
  Optional,
  Primitive,
  PrimitiveName,
  Type,
  Union,
} from "@apexlang/core/model";
import { capitalize, isPrimitive, isService, isVoid } from "../utils";
import { fieldName, methodName } from "./helpers";

export type NamedType = Alias | Type | Union | Enum;

export class GRPCVisitor extends BaseVisitor {
  private input: { [name: string]: NamedType } = {};
  private output: { [name: string]: NamedType } = {};

  visitNamespaceBefore(context: Context): void {
    const ns = context.namespace;
    const visitor = new InputOutputVisitor(this.writer);
    ns.accept(context, visitor);
    this.input = visitor.input;
    this.output = visitor.output;

    const packageName = context.config.package || "module";
    const module = context.config.module;
    const protoPackage = context.config.protoPackage || module + "/proto";
    this.write(`// Code generated by @apexlang/codegen. DO NOT EDIT.

package ${packageName}
  
import (
  "context"

  "google.golang.org/grpc"\n`);
    visitor.imports.forEach((i) => this.write(`"${i}"\n`));

    this.write(`
	"github.com/apexlang/api-go/transport/tgrpc"
	pb "${protoPackage}"
)\n\n`);
    super.triggerNamespaceBefore(context);
  }

  visitRoleBefore(context: Context): void {
    if (!isService(context)) {
      return;
    }

    const { role } = context;
    this.write(`func ${role.name}GRPC(s ${role.name}) tgrpc.RegisterFn {
  return func(server grpc.ServiceRegistrar) {
    pb.Register${role.name}Server(server, New${role.name}GRPCWrapper(s))
  }
}

type ${role.name}GRPCWrapper struct {
  pb.Unimplemented${role.name}Server
  service ${role.name}
}

func New${role.name}GRPCWrapper(service ${role.name}) *${role.name}GRPCWrapper {
  return &${role.name}GRPCWrapper{
    service: service,
  }
}\n\n`);
  }

  visitOperation(context: Context): void {
    if (!isService(context)) {
      return;
    }

    const { role, operation } = context;
    const returnType = operation.type;
    const operName = capitalize(operation.name);
    this.write(
      `func (s *${role.name}GRPCWrapper) ${operName}(ctx context.Context, `
    );
    if (operation.isUnary()) {
      const param = operation.parameters[0].type;
      switch (param.kind) {
        case Kind.Void:
          this.write(`*emptypb.Empty`);
          break;
        case Kind.Type:
          this.write(`request *pb.${(param as Named).name}`);
          break;
      }
    } else if (operation.parameters.length > 0) {
      this.write(`args *pb.${operName}Args`);
    } else {
      this.write(`_ *emptypb.Empty`);
    }
    this.write(`) (`);
    switch (returnType.kind) {
      case Kind.Void:
        this.write(`*emptypb.Empty`);
        break;
      case Kind.Primitive:
        const p = operation.type as Primitive;
        switch (p.name) {
          case PrimitiveName.String:
            this.write(`*wrapperspb.StringValue`);
            break;
          // case PrimitiveName.String:
          //   this.write(`*wrapperspb.StringValue`);
          //   break;
        }
        break;
      case Kind.Type:
        this.write(`*pb.${(returnType as Named).name}`);
        break;
    }
    this.write(`, error) {\n`);

    if (operation.isUnary()) {
      this.write(
        `input := convertInput${
          (operation.parameters[0].type as Named).name
        }(request)\n`
      );
      if (!isVoid(operation.type)) {
        this.write(`result, `);
      }
      this.write(`err := s.service.${methodName(
        operation,
        operation.name
      )}(ctx, input)
      if err != nil {
      	return nil, tgrpc.Error(err)
      }\n`);
    } else {
      const params = operation.parameters
        .map((p) => `, args.${capitalize(p.name)}`)
        .join("");
      if (!isVoid(operation.type)) {
        this.write(`result, `);
      }
      this.write(`err := s.service.${methodName(
        operation,
        operation.name
      )}(ctx${params})
      if err != nil {
      	return nil, tgrpc.Error(err)
      }\n`);
    }

    switch (operation.type.kind) {
      case Kind.Void:
        this.write(`return &emptypb.Empty{}, nil\n`);
        break;
      case Kind.Type:
        this.write(
          `return convertOutput${(operation.type as Named).name}(result), nil\n`
        );
      case Kind.Primitive:
        const p = operation.type as Primitive;
        switch (p.name) {
          case PrimitiveName.String:
            this.write(`return &wrapperspb.StringValue{Value: result}, nil\n`);
            break;
          // TODO
        }
    }
    this.write(`}\n\n`);
  }

  visitNamespaceAfter(context: Context): void {
    for (let name of Object.keys(this.input)) {
      const named = this.input[name];
      switch (named.kind) {
        case Kind.Type:
          const t = named as Type;
          this.writeInputType(t);
          break;
      }
    }

    for (let name of Object.keys(this.output)) {
      const named = this.output[name];
      switch (named.kind) {
        case Kind.Type:
          const t = named as Type;
          this.writeOutputType(t);
          break;
      }
    }
  }

  writeOutputType(t: Type) {
    this.write(`func convertOutput${t.name}(from *${t.name}) *pb.${t.name} {
      return &pb.${t.name}{\n`);
    t.fields.forEach((f) => {
      switch (f.type.kind) {
        case Kind.Optional:
          const optType = (f.type as Optional).type;
          switch (optType.kind) {
            case Kind.Primitive:
              const prim = optType as Primitive;
              let wrapperStart = "";
              let wrapperEnd = "";
              switch (prim.name) {
                case PrimitiveName.I16:
                  wrapperStart = `tgrpc.ConvertOutputI16Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.I8:
                  wrapperStart = `tgrpc.ConvertOutputI8Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.U16:
                  wrapperStart = `tgrpc.ConvertOutputU16Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.U8:
                  wrapperStart = `tgrpc.ConvertOutputU8Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.DateTime:
                  wrapperStart = `tgrpc.ConvertOutputTimestamp(`;
                  wrapperEnd = `)`;
                  break;
              }
              this.write(
                `${capitalize(f.name)}: ${wrapperStart}from.${fieldName(
                  f,
                  f.name
                )}${wrapperEnd},\n`
              );
              break;
            case Kind.Type:
              const ft = optType as Type;
              this.write(
                `${capitalize(f.name)}: convertOutput${
                  ft.name
                }(from.${fieldName(f, f.name)}),\n`
              );
              break;
          }
          break;
        case Kind.Primitive:
          const prim = f.type as Primitive;
          let wrapperStart = "";
          let wrapperEnd = "";
          switch (prim.name) {
            case PrimitiveName.I16:
            case PrimitiveName.I8:
              wrapperStart = `int32(`;
              wrapperEnd = ")";
              break;
            case PrimitiveName.U16:
            case PrimitiveName.U8:
              wrapperStart = `uint32(`;
              wrapperEnd = ")";
              break;
            case PrimitiveName.DateTime:
              wrapperStart = `timestamppb.New(`;
              wrapperEnd = `)`;
              break;
          }
          this.write(
            `${capitalize(f.name)}: ${wrapperStart}from.${fieldName(
              f,
              f.name
            )}${wrapperEnd},\n`
          );
          break;
        case Kind.Type:
          const ft = f.type as Type;
          this.write(
            `${capitalize(f.name)}: convertOutput${ft.name}(&from.${fieldName(
              f,
              f.name
            )}),\n`
          );
          break;
      }
    });
    this.write(`\t}
  }\n\n`);
  }

  writeInputType(t: Type) {
    this.write(`func convertInput${t.name}(from *pb.${t.name}) *${t.name} {
      return &${t.name}{\n`);
    t.fields.forEach((f) => {
      switch (f.type.kind) {
        case Kind.Optional:
          const optType = (f.type as Optional).type;
          switch (optType.kind) {
            case Kind.Primitive:
              const prim = optType as Primitive;
              let wrapperStart = "";
              let wrapperEnd = "";
              switch (prim.name) {
                case PrimitiveName.I16:
                  wrapperStart = `tgrpc.ConvertInputI16Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.I8:
                  wrapperStart = `tgrpc.ConvertInputI8Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.U16:
                  wrapperStart = `tgrpc.ConvertInputU16Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.U8:
                  wrapperStart = `tgrpc.ConvertInputU8Ptr(`;
                  wrapperEnd = ")";
                  break;
                case PrimitiveName.DateTime:
                  wrapperStart = `tgrpc.ConvertInputTimestamp(`;
                  wrapperEnd = `)`;
                  break;
              }
              this.write(
                `${fieldName(f, f.name)}: ${wrapperStart}from.${capitalize(
                  f.name
                )}${wrapperEnd},\n`
              );
              break;
            case Kind.Type:
              const ft = optType as Type;
              this.write(
                `${fieldName(f, f.name)}: convertInput${
                  ft.name
                }(from.${capitalize(f.name)}),\n`
              );
              break;
          }
          break;
        case Kind.Primitive:
          const prim = f.type as Primitive;
          let wrapperStart = "";
          let wrapperEnd = "";
          switch (prim.name) {
            case PrimitiveName.I16:
              wrapperStart = `int16(`;
              wrapperEnd = ")";
              break;
            case PrimitiveName.I8:
              wrapperStart = `int8(`;
              wrapperEnd = ")";
              break;
            case PrimitiveName.U16:
              wrapperStart = `uint16(`;
              wrapperEnd = ")";
              break;
            case PrimitiveName.U8:
              wrapperStart = `uint8(`;
              wrapperEnd = ")";
              break;
            case PrimitiveName.DateTime:
              wrapperEnd = `.AsTime()`;
              break;
          }
          this.write(
            `${fieldName(f, f.name)}: ${wrapperStart}from.${capitalize(
              f.name
            )}${wrapperEnd},\n`
          );
          break;
        case Kind.Type:
          const ft = f.type as Type;
          this.write(
            `${fieldName(f, f.name)}: *convertInput${ft.name}(from.${capitalize(
              f.name
            )}),\n`
          );
          break;
      }
    });
    this.write(`\t}
  }\n\n`);
  }
}

export class InputOutputVisitor extends BaseVisitor {
  imports: Set<string> = new Set();
  input: { [name: string]: NamedType } = {};
  output: { [name: string]: NamedType } = {};
  // hasDateTime: boolean = false;
  // hasEmpty: boolean = false;

  visitOperation(context: Context): void {
    if (!isService(context)) {
      return;
    }
    const { operation } = context;
    if (isVoid(operation.type) || operation.parameters.length == 0) {
      this.imports.add("google.golang.org/protobuf/types/known/emptypb");
    }
    if (operation.isUnary()) {
      this.checkSingleType(operation.parameters[0].type);
    }
    this.checkSingleType(operation.type);
    this.checkType(operation.type, this.output);
  }

  visitParameter(context: Context): void {
    if (!isService(context)) {
      return;
    }
    const { parameter } = context;
    this.checkType(parameter.type, this.input);
  }

  checkSingleType(a: AnyType) {
    if (isPrimitive(a)) {
      const p = a as Primitive;
      if (p.name == PrimitiveName.DateTime) {
        this.imports.add("google.golang.org/protobuf/types/known/timestamppb");
      } else {
        this.imports.add("google.golang.org/protobuf/types/known/wrapperspb");
      }
    }
  }

  checkType(a: AnyType, m: { [name: string]: AnyType }) {
    switch (a.kind) {
      case Kind.Primitive:
        const p = a as Primitive;
        if (p.name == PrimitiveName.DateTime) {
          this.imports.add(
            "google.golang.org/protobuf/types/known/timestamppb"
          );
        }
        break;

      case Kind.Type:
        const t = a as Type;
        m[t.name] = t;
        t.fields.forEach((f) => this.checkType(f.type, m));
      // TODO: other named types
    }
  }
}
